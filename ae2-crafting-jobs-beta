local mon = peripheral.find("monitor")
local me = peripheral.find("me_bridge")

if not mon then error("Kein Monitor gefunden!") end
if not me then error("Keine ME-Bridge gefunden!") end

-- Größe des Monitors merken
local monWidth, monHeight = mon.getSize()

-- Funktion zum Formatieren großer Zahlen
local function formatBytes(bytes)
    if bytes >= 1e9 then
        return string.format("%.2fG", bytes / 1e9)
    elseif bytes >= 1e6 then
        return string.format("%.2fM", bytes / 1e6)
    elseif bytes >= 1e3 then
        return string.format("%.2fK", bytes / 1e3)
    else
        return tostring(bytes)
    end
end

-- Text zentriert schreiben
local function writeCentered(text, y, color)
    local x = math.floor((monWidth - #text) / 2) + 1
    mon.setCursorPos(x, y)
    if color then mon.setTextColor(color) end
    mon.write(text)
    mon.setTextColor(colors.white)
end

-- Monitor vorbereiten
local function prepareMonitor()
    mon.clear()
    mon.setTextScale(1)
    mon.setBackgroundColor(colors.black)
    mon.setTextColor(colors.white)
end

-- Monitor leeren
local function clearMonitor()
    for y = 1, monHeight do
        mon.setCursorPos(1, y)
        mon.clearLine()
    end
end

-- Speichert Button-Positionen für Events
local buttons = {}

local function displayCPUs()
    clearMonitor()
    buttons = {} -- Alte Buttons löschen
    local y = 1
    writeCentered("AE2 Crafting Usage Monitor", y)
    y = y + 2

    local cpus = me.getCraftingCPUs()
    if not cpus or #cpus == 0 then
        writeCentered("Keine Crafting CPUs gefunden.", y)
        return
    end

    table.sort(cpus, function(a, b)
        return (a.isBusy == false and b.isBusy == true)
    end)

    for i, cpu in ipairs(cpus) do
        -- CPU Nummer
        writeCentered("CPU " .. i, y)
        y = y + 1

        -- Status Zeile
        local statusText = cpu.isBusy and "Busy" or "Ready"
        local statusColor = cpu.isBusy and colors.red or colors.green
        writeCentered(statusText .. " | Storage: " .. formatBytes(cpu.storage), y, statusColor)
        y = y + 1

        -- CoProc für Ready CPUs
        if not cpu.isBusy then
            writeCentered("CoProc: " .. cpu.coProcessors, y)
            y = y + 1
        end

        -- Item / Quantity für Busy CPUs
        if cpu.isBusy and cpu.craftingJob and cpu.craftingJob.resource then
            local fullName = cpu.craftingJob.resource.name or "Unknown"
            local itemName = fullName:match(":(.+)$") or fullName
            local qty = cpu.craftingJob.quantity or 0

            writeCentered("Item: " .. itemName, y, colors.yellow)
            y = y + 1
            writeCentered("Quantity: " .. qty, y)
            y = y + 1

            -- Cancel-Button für Busy CPUs
            local buttonText = "[ CANCEL ]"
            local buttonX = math.floor((monWidth - #buttonText) / 2) + 1
            mon.setCursorPos(buttonX, y)
            mon.setTextColor(colors.red)
            mon.write(buttonText)
            mon.setTextColor(colors.white)

            -- Button-Position speichern
            buttons[#buttons + 1] = {x1 = buttonX, x2 = buttonX + #buttonText - 1, y = y, cpu = cpu}

            y = y + 2
        else
            y = y + 1
        end

        if y > monHeight then break end
    end
end

prepareMonitor()

-- Event Loop
while true do
    displayCPUs()
    local event, side, x, y = os.pullEvent("monitor_touch")
    for _, button in ipairs(buttons) do
        if y == button.y and x >= button.x1 and x <= button.x2 then
            -- Cancel Job ausführen
            if button.cpu.craftingJob then
                local ok, err = pcall(function()
                    button.cpu.craftingJob:cancel()
                end)
                if ok then
                    print("Job abgebrochen.")
                else
                    print("Fehler beim abbrechen: " .. tostring(err))
                end
            end
        end
    end
end
